{
  "metadata": {
    "purpose": "Oblique strategies for creative architectural thinking",
    "version": "3.0.0",
    "lastUpdated": "2025-08-18",
    "inspiration": "Brian Eno's Oblique Strategies adapted for software architecture"
  },
  "strategies": [
    {
      "text": "What would you do if you knew you couldn't fail?",
      "category": "risk-perspective",
      "integrationPattern": "Challenge assumptions about technical constraints and encourage bold architectural decisions."
    },
    {
      "text": "Consider the opposite of your first instinct",
      "category": "alternative-thinking", 
      "integrationPattern": "If thinking monolithic, explore distributed. If thinking synchronous, explore asynchronous."
    },
    {
      "text": "What is the simplest thing that could possibly work?",
      "category": "simplicity",
      "integrationPattern": "Strip away complexity and focus on the minimal viable architecture."
    },
    {
      "text": "How would this look from the user's perspective?",
      "category": "user-focus",
      "integrationPattern": "Shift focus from technical elegance to user value and experience."
    },
    {
      "text": "What if this had to work with 100x the current load?",
      "category": "scale-thinking",
      "integrationPattern": "Force consideration of scalability constraints and bottlenecks."
    },
    {
      "text": "Remove the most expensive component",
      "category": "constraint-thinking",
      "integrationPattern": "Identify and eliminate the highest-cost element to drive creative solutions."
    },
    {
      "text": "Make it more human",
      "category": "human-centered",
      "integrationPattern": "Focus on developer experience, maintainability, and team dynamics."
    },
    {
      "text": "What are you not seeing?",
      "category": "blind-spots",
      "integrationPattern": "Identify hidden assumptions and unconsidered factors."
    },
    {
      "text": "How would you explain this to a 5-year-old?",
      "category": "simplification",
      "integrationPattern": "Force clear, simple explanations that reveal complexity."
    },
    {
      "text": "If you had to ship in one day, what would you cut?",
      "category": "timeboxing",
      "integrationPattern": "Scope ruthlessly to essentials; identify deferrable complexity."
    },
    {
      "text": "Add a measurable outcome",
      "category": "kpi-oriented",
      "integrationPattern": "Define a KPI (latency, error rate, cost) and design toward it."
    },
    {
      "text": "Switch from synchronous to asynchronous (or vice versa)",
      "category": "interaction-model",
      "integrationPattern": "Explore event-driven, queues, and backpressure or simplify to request/response."
    },
    {
      "text": "Fail on purpose, then design for it",
      "category": "resilience",
      "integrationPattern": "Introduce failure modes and add retries, timeouts, bulkheads, circuit breakers."
    },
    {
      "text": "Design the observability first",
      "category": "observability",
      "integrationPattern": "Start from logs, metrics, traces; make unknowns measurable."
    },
    {
      "text": "Remove one layer of abstraction",
      "category": "abstraction",
      "integrationPattern": "Flatten over-engineered layers to restore clarity and performance."
    },
    {
      "text": "Make a small prototype that proves the riskiest assumption",
      "category": "prototyping",
      "integrationPattern": "Spike the hardest part; limit the prototype to 4 hours."
    },
    {
      "text": "Document the decision before you make it",
      "category": "adr",
      "integrationPattern": "Write an ADR with context, options, and consequences to reveal trade-offs."
    },
    {
      "text": "Invert the dependency",
      "category": "architecture",
      "integrationPattern": "Use ports/adapters or dependency inversion to decouple volatile parts."
    },
    {
      "text": "Design for deletion",
      "category": "evolution",
      "integrationPattern": "Make modules replaceable; avoid hidden coupling and shared state."
    },
    {
      "text": "Add a contract",
      "category": "interface",
      "integrationPattern": "Define explicit interfaces and SLAs; version schemas and APIs."
    },
    {
      "text": "Cache the right thing",
      "category": "performance",
      "integrationPattern": "Choose idempotent layers; decide eviction, freshness, and invalidation triggers."
    },
    {
      "text": "Secure the boundary, not just the core",
      "category": "security",
      "integrationPattern": "Threat-model inputs/outputs, least privilege, defense-in-depth at edges."
    },
    {
      "text": "Make the cost visible",
      "category": "finops",
      "integrationPattern": "Annotate components with compute/storage/network cost and optimize hot paths."
    },
    {
      "text": "Add a kill switch",
      "category": "operability",
      "integrationPattern": "Introduce feature flags and safe rollbacks; plan for rapid disable."
    },
    {
      "text": "Name the invariants",
      "category": "correctness",
      "integrationPattern": "State what must never change; design checks around them."
    },
    {
      "text": "Budget technical debt intentionally",
      "category": "debt",
      "integrationPattern": "Track debt as first-class with pay-down windows and explicit trade-offs."
    },
    {
      "text": "Use standards before inventing",
      "category": "reuse",
      "integrationPattern": "Prefer protocols and widely-used libraries; reduce bespoke glue."
    },
    {
      "text": "Draw it as a sequence diagram",
      "category": "communication",
      "integrationPattern": "Visualize interactions; hotspots and coupling become obvious."
    },
    {
      "text": "Make it reversible",
      "category": "risk",
      "integrationPattern": "Plan migrations with dual writes, shadow reads, and rollbacks."
    },
    {
      "text": "Prefer idempotency at boundaries",
      "category": "reliability",
      "integrationPattern": "Design external interactions to be safely retried."
    },
    {
      "text": "Introduce a bounded context",
      "category": "domain",
      "integrationPattern": "Split language and data models to reduce cross-cutting change."
    },
    {
      "text": "Let the metrics choose",
      "category": "experimentation",
      "integrationPattern": "Run a small experiment; decide by measured outcome, not opinion."
    },
    {
      "text": "Write the README first",
      "category": "docs",
      "integrationPattern": "Describe how itâ€™s used and operated; design to that experience."
    },
    {
      "text": "Prefer contracts at boundaries",
      "category": "interface",
      "integrationPattern": "Define schemas and SLAs at service boundaries; validate at ingress/egress."
    },
    {
      "text": "Make failure visible early",
      "category": "reliability",
      "integrationPattern": "Introduce circuit breakers, timeouts, and clear error budgets upfront."
    },
    {
      "text": "Trade latency for cost (or vice versa)",
      "category": "latency-cost",
      "integrationPattern": "Use caching, batching, or tiered storage guided by SLOs and budgets."
    },
    {
      "text": "Bias toward reversibility",
      "category": "migration",
      "integrationPattern": "Design migrations with dual-writes, shadow reads, and easy rollback."
    },
    {
      "text": "Instrument before optimizing",
      "category": "observability",
      "integrationPattern": "Add traces, metrics, and logs to measure hotspots before changes."
    },
    {
      "text": "Use standards before inventing protocols",
      "category": "reuse",
      "integrationPattern": "Prefer HTTP, gRPC, OpenAPI, JSON Schema, and OpenTelemetry where possible."
    },
    {
      "text": "Small slice, end-to-end",
      "category": "delivery",
      "integrationPattern": "Deliver a vertical slice through UI/API/storage to validate assumptions."
    },
    {
      "text": "Fail closed at trust boundaries",
      "category": "security",
      "integrationPattern": "Treat inputs as hostile; enforce least privilege and explicit allow-lists."
    },
    {
      "text": "Prefer idempotency at writes",
      "category": "correctness",
      "integrationPattern": "Use idempotency keys, natural keys, and upserts to enable safe retries."
    },
    {
      "text": "Draw the unhappy path",
      "category": "risk",
      "integrationPattern": "Map failure modes and backoffs; design bulkheads and DLQs for protection."
    },
    {
      "text": "Name the ubiquitous language",
      "category": "domain",
      "integrationPattern": "Align terminology across teams; reflect it in APIs, events, and docs."
    }
  ]
}
